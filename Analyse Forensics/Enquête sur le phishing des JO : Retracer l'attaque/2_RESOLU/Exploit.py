from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import padding
import hashlib
import base64
import os


# Function to generate key from base64 encoded key content
def generate_key_from_base64(base64_key, desired_key_size):
    decoded_key = base64.b64decode(base64_key)
    sha256 = hashlib.sha256()
    sha256.update(decoded_key)
    full_key = sha256.digest()
    return full_key[:desired_key_size]


# Function to create a Rijndael cipher object
def create_cipher(key, iv):
    algorithm = algorithms.AES(key)  # AES is a subset of Rijndael
    cipher = Cipher(algorithm, modes.CBC(iv), backend=default_backend())
    return cipher


# Constants
key_file = "recovered/key.txt"  # Path to the key file
iv_file = "recovered/iv"  # Path to the IV file
encrypted_files_dir = (
    "encrypted_files"  # Directory containing encrypted .shutlock files
)
decrypted_files_dir = "decrypted_files"  # Directory to save decrypted files
block_size = 16  # Block size for Rijndael (AES uses 16 bytes blocks)

# Read key and IV
with open(key_file, "r") as f:
    base64_key = f.read().strip()

# Read IV
with open(iv_file, "rb") as f:
    iv = f.read()

# Desired key sizes in bytes (128 bits, 192 bits, 256 bits)
desired_key_sizes = [16, 24, 32]

# Decrypt each .shutlock file in the directory
for filename in os.listdir(encrypted_files_dir):
    if filename.endswith(".shutlock"):
        encrypted_filepath = os.path.join(encrypted_files_dir, filename)
        decrypted_filepath = os.path.join(
            decrypted_files_dir, filename[:-8]
        )  # Remove .shutlock extension

        with open(encrypted_filepath, "rb") as f:
            encrypted_data = f.read()

        # Try different key sizes
        decrypted = False
        for key_size in desired_key_sizes:
            try:
                key = generate_key_from_base64(base64_key, key_size)
                cipher = create_cipher(key, iv)
                decryptor = cipher.decryptor()
                decrypted_data = decryptor.update(encrypted_data) + decryptor.finalize()

                # Unpad the decrypted data
                unpadder = padding.PKCS7(block_size * 8).unpadder()
                decrypted_data = unpadder.update(decrypted_data) + unpadder.finalize()

                # Write the decrypted data to file
                with open(decrypted_filepath, "wb") as f:
                    f.write(decrypted_data)

                print(f"Decrypted {filename} using key size {key_size * 8} bits")
                decrypted = True
                break
            except Exception as e:
                print(
                    f"Error decrypting {filename} with key size {key_size * 8} bits: {e}"
                )

        if not decrypted:
            print(f"Failed to decrypt {filename} with any key size")

print("Decryption complete.")
